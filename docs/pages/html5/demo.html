<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <canvas id="myCanvas" width="1000" height="600"></canvas>

  <div>
    <button onclick="stage.clean()">clear</button>
  </div>



管理
clearRect(x, y, width, height)            在一个画布的一个矩形区域中清除掉像素。
beginPath()            开启一条新路径的唯一方法
save()                 保存当前环境状态
restore()              恢复当前环境状态

指针
moveTo()               子路径 设置当前位置并开始一条新的子路径

路径
lineTo()               为当前的子路径添加一条直线线段
arc()                  用一个中心点和半径，为一个画布的当前子路径添加一条弧线。
arcTo()                使用目标点和一个半径，为当前的子路径添加一条弧线。
rect()                 为当前路径添加一条矩形子路径。
quadraticCurveTo()     为当前路径添加一条贝塞尔曲线。
bezierCurveTo()        为当前的子路径添加一个三次贝塞尔曲线。

路径工具
fill()                 使用指定颜色、渐变或模式来绘制或填充当前路径的内部。
stroke()               沿着当前路径绘制或画一条直线。
fillText
strokeText
closePath()            仅仅是闭合路径的功能 与beginPath没有任何联系！！！！！！！

绘制
drawImage()            绘制一幅图像
fillRect(x,y,width,height)             绘制或填充一个矩形
strokeRect()           绘制（但不填充）一个矩形。

变换
rotate(angle)                  angle以弧度计 角度与弧度换算：角度*Math.PI/180 公式进行计算 如需旋转 5 度：5*Math.PI/180
scale(scalewidth,scaleheight)  1=100% 0.5=50% 2=200% 依次类推
translate(x, y)            方法为画布的变换矩阵添加水平的和垂直的偏移。参数 dx 和 dy 添加给后续定义路径中的所有点
clip()                 用当前路径去定义的剪切区域

createLinearGradient() 返回代表线性颜色渐变的一个 CanvasGradient 对象
createPattern()        返回代表贴图图像的一个 CanvasPattern 对象
createRadialGradient() 返回代表放射颜色渐变的一个 CanvasGradient 对象





  
  
  
 


  
</body>
</html>
<script type="text/javascript">
var canvas = document.getElementById("myCanvas");
		var context = canvas.getContext("2d");
		context.strokeStyle = "black";
    context.lineWidth=5
		context.moveTo(0,0);
		context.lineTo(100,100);
		//context.stroke();
		context.strokeStyle = "red";
		context.moveTo(0,20);
		context.lineTo(100,120);
		context.stroke();


  class Scene{
    #canvas
    #context
    #width
    #height





    canvas                       // 取得画布Canvas 元素
    fillStyle                    // 填充路径的当前的颜色、模式或渐变。值：字符串、CanvasGradient 对象或 CanvasPattern 对象
    strokeStyle                  // 绘制路径的颜色、模式和渐变。值：字符串、CanvasGradient 对象或 CanvasPattern 对象
    globalAlpha                  // 绘制内容的不透明度。值：在 0.0（完全透明）和 1.0（完全不透明）范围间。默认值为 1.0
    globalCompositeOperation     // 指定颜色如何与画布上已有颜色组合（合成）
    lineCap                      // 指定线条末端如何绘制。值：butt、round和square。默认值是 butt
    lineJoin                     // 指定两条线条如何连接。值：round、bevel和miter。默认值是 "miter"
    miterLimit                   // 当 lineJoin 为miter时，这个属性指定斜连接长度和线条宽度的最大比率
    lineWidth                    // 绘制线条的线条宽度。默认值是 1.0，且必须大于 0.0。线条在路径上居中，每边有线条宽的一半    
    shadowBlur                   // 指定羽化阴影的程度。默认值是 0
    shadowColor                  // 把阴影颜色指定为CSS字符串或Web样式字符串，且可包含alpha部分来表示透明度。默认值是 black
    shadowOffsetX                // 指定阴影水平和垂直偏移。较大值使得阴影化对象漂浮在背景较高位置上。 默认值是 0
    shadowOffsetY   
    
    font
    textBaseline 
    textAlign 
    maxWidth

    constructor(canvas, width, height){
      this.#canvas = canvas
      this.#context = canvas.getContext("2d")
      this.#width = width
      this.#height = height
    }
    clean(){ this.#context.clearRect(0, 0, this.#width, this.#height) }
    drawRectFill(x, y, w, h, style){ let ctx = this.#context; ctx.fillStyle = style; ctx.fillRect(x, y, w, h) }
    drawRectStroke(x, y, w, h, style){let ctx = this.#context; ctx.strokeStyle = style; ctx.strokeRect(x, y, w, h) }
    
    /**
     * 创建弧/曲线：arc(x, y, radius, startRad, endRad, anticlockwise)
     *                   1.5π
     *                    │
     *           π ───────┼─────── 0｜2π
     *                    │
     *                   0.5π
     * 以(x,y)为圆心、半径radius的圆上的一段弧线。默认以x轴正方向为基准、顺时针旋转计算角度。
     * 以startRad起始 默认顺时针旋转 endRad结束 
     * anticlockwise 是否逆时针旋转 默认为 false
     */
    drawCircleFill(x, y, r, startAngle, endAngle, antiClock, style){
      let context = this.#context;
      context.beginPath();
      context.arc(x, y, r, startAngle, endAngle, antiClock);
      context.closePath();
      context.fillStyle = style;
      context.fill();
    }
    drawCircleStroke(x, y, r, startAngle, endAngle, antiClock, style){
      let context = this.#context;
      context.beginPath();
      context.arc(x, y, r, startAngle, endAngle, antiClock);
      context.closePath();
      context.strokeStyle = style;
      context.stroke();
    }

    /**
     * 文本
     */
    drawTextFill(text, font, textBaseline, textAlign, maxWidth, style, x, y){
      let context = this.#context;
      context.save();
      context.font = font
      context.textBaseline = textBaseline
      context.textAlign = textAlign
      context.maxWidth = maxWidth      
      context.fillStyle = style;
      maxWidth ? context.fillText(text, x, y, maxWidth) : context.fillText(text, x, y);
      context.restore();
    }
    drawTextStroke(text, font, textBaseline, textAlign, maxWidth, style, x, y){
      let context = this.#context;
      context.save();
      context.font = font
      context.textBaseline = textBaseline
      context.textAlign = textAlign
      context.maxWidth = maxWidth      
      context.strokeStyle = style;
      maxWidth ? context.strokeText(text, x, y, maxWidth) : context.strokeText(text, x, y);      
      context.restore();
    }
    /**
     * 直线
     */
    drawLine(style, lineWidth, start, end){
      let context = this.#context;
      context.strokeStyle = style;
      context.lineWidth = lineWidth;
      context.beginPath();
      context.lineTo(start[0], start[1]);
      context.lineTo(end[0], end[1]);
      context.closePath();
      context.stroke();
    }

    /**
     * 多边形
     */
    drawPolygonFill(pointsArr, style){
      let context = this.#context;
      context.beginPath();
      for(var i=0,len=pointsArr.length;i<len-1;i++){
					var start=pointsArr[i],end=pointsArr[i+1];
					context.lineTo(start[0],start[1]);
					context.lineTo(end[0],end[1]);
			}
      context.closePath();
      context.fillStyle = style;
      context.fill();
    }
    drawPolygonStroke(pointsArr, style, lineWidth){
      let context = this.#context;
      context.beginPath();
      for(var i=0,len=pointsArr.length;i<len-1;i++){
					var start=pointsArr[i],end=pointsArr[i+1];
					context.lineTo(start[0],start[1]);
					context.lineTo(end[0],end[1]);
			}
      context.closePath();
      context.lineWidth = lineWidth;
      context.strokeStyle = style;
      context.stroke();
    }
    /**
     * 图片
     * img	          规定要使用的图像、画布或视频。
       sx	sy	        可选。开始剪切的 xy 坐标位置。
       swidth sheight	可选。被剪切图像的宽度高度。
       x y	          在画布上放置图像的 xy 坐标位置。
       width height	  可选。要使用的图像的宽度高度。（伸展或缩小图像）
     */
    drawImage(img, sx, sy, swidth, sheight, x, y, width, height){
      let context = this.#context;
      context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)
    }
    aa(){
      context.save();
      context.translate(this.x + halfWith, this.y + halfHeight);
      context.rotate(((this.angle * Math.PI) / 180) * -1);
      context.drawImage(this.image, this.imgX, this.imgY, this.imgWidth, this.imgHeight, -halfWith, -halfHeight, this.width, this.height);
      context.restore();
    }
  }

  // let stage = new Scene(document.getElementById("myCanvas"), 1000, 600)
  // stage.drawRectFill(10, 10, 50, 50, '#f00')
  // stage.drawRectStroke(80, 10, 50, 50, '#0f0')
  // stage.drawCircleFill(170, 35, 25, 0, Math.PI*2, false, '#0f0')
  // stage.drawCircleStroke(240, 35, 25, 0, Math.PI*2, false, '#0f0')
  // stage.drawTextFill("文本样本", "20px Georgia", null, 'left', 200, '#f00', 300, 40)
  // stage.drawTextStroke("文本样本", "20px Georgia", null, 'left', 200, '#f00', 400, 40)
  // stage.drawLine('#00f', 5, [500,35], [600,35])
  // stage.drawPolygonFill([[10,80], [100,80], [100, 180], [20, 180]], '#00f')
  // stage.drawPolygonStroke([[120,80], [200,80], [200, 180], [130, 180]], '#f00')
  // var img = new Image()
  // img.onload = function(){
  //   stage.drawImage(this, 0, 0, 202, 205, 10, 220, 80, 80)
  // }
  // img.src = '001.png'
  
  

</script>

  

  
  
  
  
